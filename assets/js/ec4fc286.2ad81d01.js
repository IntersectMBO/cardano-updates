"use strict";(self.webpackChunkcardano_updates=self.webpackChunkcardano_updates||[]).push([[52900],{3905:(e,t,r)=>{r.d(t,{Zo:()=>m,kt:()=>h});var a=r(67294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var s=a.createContext({}),c=function(e){var t=a.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},m=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=c(r),p=n,h=d["".concat(s,".").concat(p)]||d[p]||u[p]||i;return r?a.createElement(h,o(o({ref:t},m),{},{components:r})):a.createElement(h,o({ref:t},m))}));function h(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,o=new Array(i);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:n,o[1]=l;for(var c=2;c<i;c++)o[c]=r[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}p.displayName="MDXCreateElement"},3855:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=r(87462),n=(r(67294),r(3905));const i={title:"Performance & Tracing Update",slug:"2026-02-25-performance-and-tracing",authors:"mgmeier",tags:["performance-tracing"],hide_table_of_contents:!1},o=void 0,l={permalink:"/2026-02-25-performance-and-tracing",editUrl:"https://github.com/intersectmbo/cardano-updates/tree/main/blog/2026-02-25-performance-and-tracing.md",source:"@site/blog/2026-02-25-performance-and-tracing.md",title:"Performance & Tracing Update",description:"High level summary",date:"2026-02-25T00:00:00.000Z",formattedDate:"February 25, 2026",tags:[{label:"performance-tracing",permalink:"/tags/performance-tracing"}],readingTime:4.21,hasTruncateMarker:!1,authors:[{name:"Michael Karg",title:"Performance and Tracing Team Lead",url:"https://github.com/mgmeier",imageURL:"https://github.com/mgmeier.png",key:"mgmeier"}],frontMatter:{title:"Performance & Tracing Update",slug:"2026-02-25-performance-and-tracing",authors:"mgmeier",tags:["performance-tracing"],hide_table_of_contents:!1},prevItem:{title:"Mithril Team Update",permalink:"/2026-02-25-mithril"},nextItem:{title:"Mithril Team Update",permalink:"/2026-02-18-mithril"}},s={authorsImageUrls:[void 0]},c=[{value:"High level summary",id:"high-level-summary",level:2},{value:"Low level overview",id:"low-level-overview",level:2},{value:"Benchmarking",id:"benchmarking",level:3},{value:"Development",id:"development",level:3},{value:"Infrastructure",id:"infrastructure",level:3},{value:"Tracing",id:"tracing",level:3},{value:"Leios",id:"leios",level:3},{value:"Node Diversity",id:"node-diversity",level:3}],m={toc:c},d="wrapper";function u(e){let{components:t,...r}=e;return(0,n.kt)(d,(0,a.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h2",{id:"high-level-summary"},"High level summary"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Benchmarking"),": Release benchmarks for ",(0,n.kt)("inlineCode",{parentName:"li"},"10.5.4")," and ",(0,n.kt)("inlineCode",{parentName:"li"},"10.6.2"),"; Parallel GC benchmarks."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Development"),": Preparation of new ",(0,n.kt)("inlineCode",{parentName:"li"},"PlutusV3")," baseline."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Infrastructure"),": Performance cluster gets custom, isolated Nix cache - safe benchmarks for security-critical changes."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Tracing"),": Improving robustness by forcing lazy values in controlled sections of code."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Leios"),": LTL Trace Verifier completed, waiting integration."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Node Diversity"),": Formal trace schema definition entering validation phase; Trace forwarding in native Rust entering testing.")),(0,n.kt)("h2",{id:"low-level-overview"},"Low level overview"),(0,n.kt)("h3",{id:"benchmarking"},"Benchmarking"),(0,n.kt)("p",null,"We've performed, analysed and published relase benchmarks for both Node versions ",(0,n.kt)("inlineCode",{parentName:"p"},"10.5.4")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"10.6.2"),". We could determine both to be free of performance regressions. The ",(0,n.kt)("inlineCode",{parentName:"p"},"10.6.2")," release contains the new 'Defensive Mempool' feature, which\nis therefore also covered by our benchmark. The ",(0,n.kt)("inlineCode",{parentName:"p"},"10.6.2")," release has shown to be somewhat more efficient in its use of CPU time, but exhibited a slightly higher tendency to perform Major GC cycles.  "),(0,n.kt)("p",null,"To that end, we've reopened an old PR which changes the default / recommended GC settings for the Node process to a parallel, load-balanced GC (",(0,n.kt)("a",{parentName:"p",href:"https://github.com/IntersectMBO/cardano-node/pull/6222"},"cardano-node PR#6222"),"). The motivation is to update the current recommended settings (which are still tuned to GHC8.10) such\nthat the ocurrence of Major GC cycles is greatly reduced (as they may temporarily halt the Node process to complete). We found in our benchmark that, apart from being even slightly more efficient regarding CPU time, the occurrence of Major GCs could\nbe reduced by almost factor 30."),(0,n.kt)("h3",{id:"development"},"Development"),(0,n.kt)("p",null,"We're performing an overhaul of the ",(0,n.kt)("inlineCode",{parentName:"p"},"plutus-scripts-bench")," package, a library of benchmarkable Plutus scripts targeting various aspects of the Plutus interpreter, the respective cost model and the execution budgets. The aim is\nto create up-to-date performance baselines by using exclusively ",(0,n.kt)("inlineCode",{parentName:"p"},"PlutusV3")," scripts that have been built with a recent version of the compiler - thus factoring in potential performance improvements in generated code.\nCurrently, the PR ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/IntersectMBO/cardano-node/pull/6440"},"cardano-node PR#6440")," is work in progress."),(0,n.kt)("h3",{id:"infrastructure"},"Infrastructure"),(0,n.kt)("p",null,"Up to now, a benchmarking deployment required the target commit to be a public item on GitHub; the ",(0,n.kt)("inlineCode",{parentName:"p"},"nix")," build (or cache retrieval from our CI) would be decentralized, with each cluster instance creating the benchmarking artifact independently.\nWhen there's a requirement to benchmark security-critical changes in an isolated, opaque fashion, this approach would reach its limits promptly. Together with SRE, we devised a way to achieve just that: An artifact can be built from a local commit on one\ncluster instance into its ",(0,n.kt)("inlineCode",{parentName:"p"},"nix")," store, which in turn will serve as a substituter (i.e. cache) in a centralized manner for all other instances (",(0,n.kt)("a",{parentName:"p",href:"https://github.com/IntersectMBO/cardano-node/pull/6450"},"cardano-node PR#6450"),")."),(0,n.kt)("h3",{id:"tracing"},"Tracing"),(0,n.kt)("p",null,"The new tracing system highly encourages trace values to be lazy. Thus, the emitting thread has the lowest possible overhead when doing so - which is highly relevant when you're on a hot code path. Furthermore, this overhead is assumed\nto be a constant factor - regardless of whether those traces are consumed by any subscriber or not. We're currently exploring an approach to increase robustness, guarding against shaky implementations of trace values themselves. The burden\nof evaluating a lazy trace still remains with a subscriber, however, this is now decoupled from handing over the trace result (such as a log line, a metric, etc.). By forcing a lazy trace value in a controlled section of code, immediately prior\nto handover, the system will reliably handle even blatant implementation errors in lazy traces."),(0,n.kt)("h3",{id:"leios"},"Leios"),(0,n.kt)("p",null,"The Linear Temporal Logic (LTL) Trace Verifier ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/jutaro/cardano-trace-ltl"},"Cardano Trace LTL")," has reached production readiness. It is able to ingest multiple streams of trace evidence, basically multiple Node log files as they're being produced, and\ncontinuously evaluate a set of LTL propositions against them. While performant, real-time evaluation is a valuable thing to have, it required some of the LTL operators to be bounded to be able to operate in constant space over a long time.\nWe've discussed our fragment of LTL with Formal Methods to start building a collection of properties worth checking, and to ensure there's provably no disjoint semantics introduced by the bounded operators.  "),(0,n.kt)("p",null,"The service is currently being integrated with the existing tooling in the ",(0,n.kt)("inlineCode",{parentName:"p"},"cardano-node")," project, and will form a regular part of Leios setups / deployments in the future."),(0,n.kt)("h3",{id:"node-diversity"},"Node Diversity"),(0,n.kt)("p",null,"We've reached basic viability of the comprehensive formal schema definition of all the Node's existing trace messages. We're building an automated verification suite that will ensure all definitions are fully compliant\nwith existing JSON schema, as well as the observables implemented in (and the trace messages logged by) the Haskell Node conform to the defined schema. Further manual refinement of types in the schema will be the next step; eventually,\nthis will serve as a basis to automatically derive parsers, and to render a human-readable reference documentation.    "),(0,n.kt)("p",null,"The implementation of our trace / metrics forwarding mini-protocol in Rust has completed and is now in testing phase. After cleanup and merge, this allows Rust projects to emit Cardano-style structured traces directly, and forward them to a running\n",(0,n.kt)("inlineCode",{parentName:"p"},"cardano-tracer")," for logging, processing and metrics exposition."))}u.isMDXComponent=!0}}]);